use Mavenmovies;
show tables

-- 1. Retrieve the total number of rentals made in the Sakila database.
SELECT COUNT(*) AS total_rentals
FROM rental;

-- 2. Find the average rental duration (in days) of movies rented from the Sakila database.
SELECT AVG(rental_duration) AS avg_rental_duration
FROM film;

-- 3. Display the first name and last name of customers in uppercase.
SELECT UPPER(first_name) AS first_name, UPPER(last_name) AS last_name
FROM customer;

-- 4. Extract the month from the rental date and display it alongside the rental ID.
SELECT rental_id, MONTH(rental_date) AS rental_month
FROM rental;

-- 5. Retrieve the count of rentals for each customer (display customer ID and the count of rentals).
SELECT customer_id, COUNT(*) AS rental_count
FROM rental
GROUP BY customer_id;

-- 6. Find the total revenue generated by each store.
SELECT store_id, SUM(amount) AS total_revenue
FROM payment
GROUP BY store_id;

-- 7. Determine the total number of rentals for each category of movies.
SELECT fc.category_id, COUNT(r.rental_id) AS rental_count
FROM rental r
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN film_category fc ON i.film_id = fc.film_id
GROUP BY fc.category_id;

-- 8. Find the average rental rate of movies in each language.
SELECT l.name AS language_name, AVG(f.rental_rate) AS avg_rental_rate
FROM film f
JOIN language l ON f.language_id = l.language_id
GROUP BY l.name;

###### JOINS #######
-- 9. Display the title of the movie, customerâ€™s first name, and last name who rented it.
SELECT f.title, c.first_name, c.last_name
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN customer c ON r.customer_id = c.customer_id;

-- 10. Retrieve the names of all actors who have appeared in the film "Gone with the Wind."
SELECT a.first_name, a.last_name
FROM actor a
JOIN film_actor fa ON a.actor_id = fa.actor_id
JOIN film f ON fa.film_id = f.film_id
WHERE f.title = 'Gone with the Wind';

-- 11. Retrieve the customer names along with the total amount they've spent on rentals.
SELECT c.first_name, c.last_name, SUM(p.amount) AS total_spent
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
JOIN rental r ON p.rental_id = r.rental_id
GROUP BY c.customer_id;

-- 12. List the titles of movies rented by each customer in a particular city (e.g., 'London').
SELECT c.first_name, c.last_name, f.title
FROM customer c
JOIN address a ON c.address_id = a.address_id
JOIN city ci ON a.city_id = ci.city_id
JOIN rental r ON c.customer_id = r.customer_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN film f ON i.film_id = f.film_id
WHERE ci.city = 'London';

######	Advanced Joins and GROUP BY: ####

-- 13. Display the top 5 rented movies along with the number of times they've been rented.
SELECT f.title, COUNT(r.rental_id) AS rental_count
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY f.title
ORDER BY rental_count DESC
LIMIT 5;

-- 14. Determine the customers who have rented movies from both stores (store ID 1 and store ID 2).
SELECT c.first_name, c.last_name
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
JOIN inventory i ON r.inventory_id = i.inventory_id
WHERE i.store_id IN (1, 2)
GROUP BY c.customer_id
HAVING COUNT(DISTINCT i.store_id) = 2;

######## Windows Function: #########

-- 1. Rank the customers based on the total amount they've spent on rentals.
SELECT c.first_name, c.last_name, SUM(p.amount) AS total_spent,
	RANK() OVER (ORDER BY SUM(p.amount) DESC) AS rank
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
GROUP BY c.customer_id;

-- 2. Calculate the cumulative revenue generated by each film over time.
SELECT f.title, r.rental_date, SUM(p.amount) AS revenue,
       SUM(p.amount) OVER (PARTITION BY f.film_id ORDER BY r.rental_date) AS cumulative_revenue
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN payment p ON r.rental_id = p.rental_id
GROUP BY f.film_id, r.rental_date
ORDER BY f.title, r.rental_date;

-- 3. Determine the average rental duration for each film, considering films with similar lengths.
SELECT f.title, f.rental_duration, AVG(f.rental_duration) OVER (PARTITION BY f.rental_duration) AS avg_duration
FROM film f;

-- 4. Identify the top 3 films in each category based on their rental counts.
SELECT title, category_id, rental_count
FROM (
    SELECT f.title, fc.category_id, COUNT(r.rental_id) AS rental_count,
           RANK() OVER (PARTITION BY fc.category_id ORDER BY COUNT(r.rental_id) DESC) AS rank
    FROM film f
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
    JOIN film_category fc ON f.film_id = fc.film_id
    GROUP BY f.title, fc.category_id
) AS ranked_films
WHERE rank <= 3;


-- 5. Calculate the difference in rental counts between each customer's total rentals and the average rentals across all customers.
SELECT c.first_name, c.last_name, COUNT(r.rental_id) AS customer_rentals,
       AVG(COUNT(r.rental_id)) OVER () - COUNT(r.rental_id) AS rental_diff
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
GROUP BY c.customer_id;


-- 6. Find the monthly revenue trend for the entire rental store over time.
SELECT YEAR(r.rental_date) AS rental_year, MONTH(r.rental_date) AS rental_month, 
       SUM(p.amount) AS monthly_revenue,
       SUM(p.amount) OVER (ORDER BY YEAR(r.rental_date), MONTH(r.rental_date)) AS running_total_revenue
FROM rental r
JOIN payment p ON r.rental_id = p.rental_id
GROUP BY rental_year, rental_month
ORDER BY rental_year, rental_month;

-- 7. Identify the customers whose total spending on rentals falls within the top 20% of all customers.
SELECT first_name, last_name, total_spent, percentile
FROM (
    SELECT c.first_name, c.last_name, SUM(p.amount) AS total_spent,
           PERCENT_RANK() OVER (ORDER BY SUM(p.amount) DESC) AS percentile
    FROM customer c
    JOIN payment p ON c.customer_id = p.customer_id
    GROUP BY c.customer_id
) AS ranked_customers
WHERE percentile >= 0.8;


-- 8. Calculate the running total of rentals per category, ordered by rental count.
SELECT fc.category_id, COUNT(r.rental_id) AS rental_count,
       SUM(COUNT(r.rental_id)) OVER (PARTITION BY fc.category_id ORDER BY COUNT(r.rental_id)) AS running_total_rentals
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN film_category fc ON f.film_id = fc.film_id
GROUP BY fc.category_id;

-- 9. Find the films that have been rented less than the average rental count for their respective categories.
SELECT title, category_id, rental_count, avg_rental_count
FROM (
    SELECT f.title, fc.category_id, COUNT(r.rental_id) AS rental_count,
           AVG(COUNT(r.rental_id)) OVER (PARTITION BY fc.category_id) AS avg_rental_count
    FROM film f
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
    JOIN film_category fc ON f.film_id = fc.film_id
    GROUP BY f.title, fc.category_id
) AS ranked_films
WHERE rental_count < avg_rental_count;


-- 10. Identify the top 5 months with the highest revenue and display the revenue generated in each month.
SELECT YEAR(r.rental_date) AS rental_year, MONTH(r.rental_date) AS rental_month, 
       SUM(p.amount) AS monthly_revenue
FROM rental r
JOIN payment p ON r.rental_id = p.rental_id
GROUP BY rental_year, rental_month
ORDER BY monthly_revenue DESC
LIMIT 5;

###################

-- 1. First Normal Form (1NF):
-- a. Identify a table in the Sakila database that violates 1NF. 
--    Explain how you would normalize it to achieve 1NF.
-- Violation in Sakila Database: The `film` table could violate 1NF if a column stores multiple values (e.g., actors).
-- Solution: Make the `actors` column atomic by splitting it into a new table.

-- Non-compliant with 1NF:
CREATE TABLE film (
  film_id INT PRIMARY KEY,
  title VARCHAR(255),
  actors VARCHAR(255)  -- Multiple actors' names stored here.
);

-- Normalized to 1NF:
CREATE TABLE film (
  film_id INT PRIMARY KEY,
  title VARCHAR(255)
);

CREATE TABLE film_actors (
  film_id INT,
  actor_name VARCHAR(255),
  FOREIGN KEY (film_id) REFERENCES film(film_id)
);

-- 2. Second Normal Form (2NF):
-- a. Choose a table in Sakila and describe how you would determine whether it is in 2NF. 
--    If it violates 2NF, explain the steps to normalize it.
-- Violation: `rental` table could violate 2NF if `film_title` depends only on part of the composite key (`film_id`).
-- Solution: Separate `film_title` into a `film` table.

-- Original (violating 2NF):
CREATE TABLE rental (
  rental_id INT PRIMARY KEY,
  customer_id INT,
  film_id INT,
  film_title VARCHAR(255)
);

-- Normalized to 2NF:
CREATE TABLE rental (
  rental_id INT PRIMARY KEY,
  customer_id INT,
  film_id INT
);

CREATE TABLE film (
  film_id INT PRIMARY KEY,
  film_title VARCHAR(255)
);

-- 3. Third Normal Form (3NF):
-- a. Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF.
-- Violation: `customer` table violates 3NF if `city_name` depends on `address`, and `address` depends on `customer_id`.
-- Solution: Separate `city` into its own table and reference it in the `customer` table.

-- Original (violating 3NF):
CREATE TABLE customer (
  customer_id INT PRIMARY KEY,
  address VARCHAR(255),
  city_name VARCHAR(255)
);

-- Normalized to 3NF:
CREATE TABLE city (
  city_id INT PRIMARY KEY,
  city_name VARCHAR(255)
);

CREATE TABLE customer (
  customer_id INT PRIMARY KEY,
  address VARCHAR(255),
  city_id INT,
  FOREIGN KEY (city_id) REFERENCES city(city_id)
);

-- 4. Normalization Process:
-- a. Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF.
-- Table: `film`

-- 1. Unnormalized Form (UNF):
CREATE TABLE film (
  film_id INT PRIMARY KEY,
  title VARCHAR(255),
  actors VARCHAR(255)  -- Multiple actors in one column.
);

-- 2. Normalize to 1NF:
CREATE TABLE film (
  film_id INT PRIMARY KEY,
  title VARCHAR(255)
);

CREATE TABLE film_actor (
  film_id INT,
  actor_name VARCHAR(255),
  FOREIGN KEY (film_id) REFERENCES film(film_id)
);

-- 3. Normalize to 2NF:
CREATE TABLE film (
  film_id INT PRIMARY KEY,
  title VARCHAR(255)
);

CREATE TABLE actor (
  actor_id INT PRIMARY KEY,
  actor_name VARCHAR(255)
);

CREATE TABLE film_actor (
  film_id INT,
  actor_id INT,
  FOREIGN KEY (film_id) REFERENCES film(film_id),
  FOREIGN KEY (actor_id) REFERENCES actor(actor_id)
);

-- 5. CTE Basics:
-- a. Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the actor and film_actor tables.

WITH actor_film_count AS (
  SELECT a.actor_id, a.first_name, a.last_name, COUNT(fa.film_id) AS film_count
  FROM actor a
  JOIN film_actor fa ON a.actor_id = fa.actor_id
  GROUP BY a.actor_id
)
SELECT first_name, last_name, film_count
FROM actor_film_count;

-- 6. CTE with Joins:
-- a. Create a CTE that combines information from the film and language tables to display the film title, language name, and rental rate.

WITH film_language_info AS (
  SELECT f.title, l.name AS language_name, f.rental_rate
  FROM film f
  JOIN language l ON f.language_id = l.language_id
)
SELECT * FROM film_language_info;

-- 7. CTE for Aggregation:
-- a. Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and payment tables.

WITH customer_revenue AS (
  SELECT c.customer_id, c.first_name, c.last_name, SUM(p.amount) AS total_revenue
  FROM customer c
  JOIN payment p ON c.customer_id = p.customer_id
  GROUP BY c.customer_id
)
SELECT * FROM customer_revenue;

-- 8. CTE with Window Functions:
-- a. Utilize a CTE with a window function to rank films based on their rental duration from the film table.

WITH ranked_films AS (
  SELECT f.title, f.rental_duration,
         RANK() OVER (ORDER BY f.rental_duration DESC) AS rental_rank
  FROM film f
)
SELECT * FROM ranked_films;

-- 9. CTE and Filtering:
-- a. Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer table to retrieve additional customer details.

WITH frequent_customers AS (
  SELECT r.customer_id, COUNT(r.rental_id) AS rental_count
  FROM rental r
  GROUP BY r.customer_id
  HAVING rental_count > 2
)
SELECT c.customer_id, c.first_name, c.last_name
FROM frequent_customers fc
JOIN customer c ON fc.customer_id = c.customer_id;

-- 10. CTE for Date Calculations:
-- a. Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from the rental table.

WITH monthly_rentals AS (
  SELECT YEAR(r.rental_date) AS rental_year, MONTH(r.rental_date) AS rental_month, 
         COUNT(r.rental_id) AS rental_count
  FROM rental r
  GROUP BY rental_year, rental_month
)
SELECT * FROM monthly_rentals
ORDER BY rental_year, rental_month;

-- 11. CTE and Self-Join:
-- a. Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.

WITH actor_pairs AS (
  SELECT fa1.actor_id AS actor_1, fa2.actor_id AS actor_2, fa1.film_id
  FROM film_actor fa1
  JOIN film_actor fa2 ON fa1.film_id = fa2.film_id
  WHERE fa1.actor_id < fa2.actor_id
)
SELECT a1.first_name AS actor_1_first_name, a1.last_name AS actor_1_last_name,
       a2.first_name AS actor_2_first_name, a2.last_name AS actor_2_last_name, ap.film_id
FROM actor_pairs ap
JOIN actor a1 ON ap.actor_1 = a1.actor_id
JOIN actor a2 ON ap.actor_2 = a2.actor_id;

-- 12. CTE for Recursive Search:
-- a. Implement a recursive CTE to find all employees in the staff table who report to a specific manager, considering the reports_to column.
ALTER TABLE staff
ADD COLUMN manager_id INT;
UPDATE staff
SET manager_id = NULL
WHERE staff_id = 1;

UPDATE staff
SET manager_id = 1
WHERE staff_id IN (2, 3, 4);  

UPDATE staff
SET manager_id = 2
WHERE staff_id IN (5, 6);  

WITH RECURSIVE staff_hierarchy AS (
  SELECT staff_id, first_name, last_name, manager_id
  FROM staff
  WHERE manager_id IS NULL  -- Start with the top-level manager
  UNION ALL
  SELECT s.staff_id, s.first_name, s.last_name, s.manager_id
  FROM staff s
  JOIN staff_hierarchy sh ON s.manager_id = sh.staff_id
)
SELECT * FROM staff_hierarchy;

